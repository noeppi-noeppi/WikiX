{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"LibX wiki","text":"<p>LibX is a library mod for minecraft.</p> <p>You can download it on CurseForge or Modrinth.</p> <p>Use LibX in a development environment:</p> <pre><code>repositories {\n    maven {\n        name = 'ModdingX Maven'\n        url = 'https://maven.moddingx.org/'\n    }\n}\n\ndependencies {\n    annotationProcessor fg.deobf(\"org.moddingx:LibX:${mc_version}-${libx_version}\")\n    implementation fg.deobf(\"org.moddingx:LibX:${mc_version}-${libx_version}\")\n}\n</code></pre> <p>Javadoc can be found at https://moddingx.org/libx.</p>"},{"location":"first_steps.html","title":"First Steps","text":"<p>Add LibX as a dependency as described here.</p>"},{"location":"first_steps.html#declare-dependency-in-modstoml","title":"Declare dependency in mods.toml","text":"<p>Put this into your <code>mods.toml</code> file and replace <code>modid</code> with your mods id and <code>libx_version</code> with the minimum required LibX version..</p> <pre><code>[[dependencies.modid]]\n    modId=\"libx\"\n    mandatory=true\n    versionRange=\"[libx_version,)\"\n    ordering=\"NONE\"\n    side=\"BOTH\"\n</code></pre>"},{"location":"first_steps.html#extending-modx","title":"Extending ModX","text":"<p>Most stuff in LibX requires your mod class to extends <code>ModX</code>.</p> <p>This will provide you with some abstract methods for setup events, the possibility to use ModInit and config guis.</p> <p>Check out other parts of the wiki to see what other features are useful to you.</p>"},{"location":"config/index.html","title":"The LibX config system.","text":"<p>LibX provides a custom config system based on json files. This will outline the basics of the config system, for more information see the javadoc.</p>"},{"location":"config/index.html#creating-a-config","title":"Creating a config","text":"<p>A config is a java class with some annotations. Adding config values are meant to be as simple as adding a field to a class. An example for a config class is shown here:</p> <pre><code>public class MyConfig {\n\n    @Config(\"A comment for a config key\")\n    public static String someValue = \"Hello\";\n\n    @Config({\n            \"Multiline comments\",\n            \"work as well\"\n    })\n    @IntRange(min = 0, max = 20)\n    public static int value = 3;\n\n    public static class ConfigSubGroup {\n\n        @Config\n        public static List&lt;List&lt;Integer&gt;&gt; listOfIntLists = List.of(List.of(1));\n    }\n}\n</code></pre> <p>Each field annotated ith <code>@Config</code> will become a config value and the value set in the config will be put into the field. The initial value of the field will become the default value. The fields must be <code>static</code> and may not be <code>final</code>. Null values are not allowed in the fields, but in the config json. For a list of supported field types, see Config Key Types.</p> <p>To register that config, use one of the <code>ConfigManager.registerConfig</code> methods:</p> <ul> <li><code>ConfigManager.registerConfig(String, Class&lt;?&gt;, boolean)</code>:      Register the primary config for your mod.      The first argument is the modid.      The last argument is the config type.      See below.      The config is stored in <code>.minecraft/config/modid.json5</code>.</li> <li><code>ConfigManager.registerConfig(ResourceLocation, Class&lt;?&gt;, boolean)</code>:      Register a config for your mod.      The first argument is the id for the config.      The last argument is the config type.      See below.      The config is stored in <code>.minecraft/config/namespace/path.json5</code>.</li> </ul>"},{"location":"config/index.html#config-types","title":"Config Types","text":"<p>There are two types fo config:</p> <p>Common configs and client configs. Common configs are present on both client and server. They are synced from the server to the client, so a client will always have the values, that are set one the server it is currently playing on.</p> <p>Client configs on the other side are only present on the client and won't be synced.</p>"},{"location":"config/index.html#reloading-configs","title":"Reloading configs","text":"<p>Using the command <code>/libx reload</code>, configs can be reloaded.</p>"},{"location":"config/index.html#extending-the-config-system","title":"Extending the config system","text":"<p>You can add custom config mappers to make your config support more types. You can also add custom validators that can be added to field through an annotation to further validate values. This however is not described here.</p>"},{"location":"config/key_types.html","title":"List of builtin config key types","text":"<p>This list may change from time to time. For a complete list, see the javadocs of the ConfigManager class.</p> <p>This is a list of all types that can be used as a type for a config field:</p> <ul> <li><code>boolean</code> / <code>Boolean</code></li> <li><code>byte</code> / <code>Byte</code></li> <li><code>short</code> / <code>Short</code></li> <li><code>int</code> / <code>Integer</code></li> <li><code>long</code> / <code>Long</code></li> <li><code>float</code> / <code>Float</code></li> <li><code>double</code> / <code>Double</code></li> <li><code>String</code></li> <li><code>Optional&lt;T&gt;</code> if <code>T</code> is supported. Empty optionals will get <code>null</code> in the json.</li> <li><code>List&lt;T&gt;</code> if <code>T</code> is supported.</li> <li><code>Map&lt;String, T&gt;</code> if <code>T</code> is supported.</li> <li><code>Pair&lt;A, B&gt;</code> if <code>A</code> and <code>B</code> are supported.</li> <li><code>Triple&lt;A, B, C&gt;</code> if <code>A</code>, <code>B</code>  and <code>C</code> are supported.</li> <li>Every <code>enum</code></li> <li>Every <code>record</code> if the types of all record components are supported.</li> <li><code>UUID</code></li> <li><code>ResourceLocation</code></li> <li><code>ResourceList</code></li> <li><code>Ingredient</code></li> <li><code>IngredientStack</code></li> <li><code>Component</code></li> </ul>"},{"location":"datagen/index.html","title":"The LibX Datagen System","text":"<p>LibX provides a system for datagen that can load datapack registries during datagen and allows easy generation of datapack registry content as well as tags for datapack registry content.</p> <p>The LibX datagen system works in three stages:</p> <ul> <li>registry setup: In this stage, the datapack registries can be populated with values. Output should not be generated during this stage. At the end of this stage, almost all datapack registries are frozen.</li> <li>extension setup: This stage is similar to the registry setup stage. However most datapack registries are frozen. This stage is used to populate extension registries (see below).</li> <li>datagen: At the beginning of this stage, all elements that were newly added to the registries in earlier steps are generated. After that regular data providers run and generate their output.</li> </ul>"},{"location":"datagen/index.html#extension-registries","title":"Extension registries","text":"<p>Some registries reference elements in other registries by the id used to register them. (For example the biome surface registry from SandBox). In order to populate these registries, the other datapack registries must be already frozen, hence the existence of the extension setup stage.</p> <p>To mark a registry as an extension registry, use</p> <pre><code>DatagenSystem.registerExtensionRegistry(REGISTRY_KEY);\n</code></pre> <p>Note that this is global, so you should only ever use it for registries, you add yourself.</p>"},{"location":"datagen/index.html#pack-targets","title":"Pack targets","text":"<p>In some cases it might be desired to generate data not only for a single datapack but for multiple. For example, one might want to put some data into a dynamic datapack and switch it on depending on a config option.</p> <p>To support this, LibX knows the concept of a <code>PackTarget</code>. A <code>PackTarget</code> stores the target location for generated output files and owns a registry set with all elements that are known for this output. Each output can have multiple parents. If an element is added to the registry set of one of the parents, the child pack target will inherit that element and assume its existence without generating it again.</p> <p>It is possible to create a vanilla <code>PackOutput</code> from a <code>PackTarget</code> to use it with non-LibX providers. </p>"},{"location":"datagen/index.html#using-the-system","title":"Using the system","text":"<p>In order to use the system, add the following to your mods constructor:</p> <pre><code>DatagenSystem.create(this, system -&gt; {\n    ...\n});\n</code></pre> <p>Inside the lambda, you can then configure the system, create auxiliary pack targets and add providers to the different stages. Providers run in the order, they were added and can query providers that have run before when they are created.</p>"},{"location":"modinit/index.html","title":"ModInit","text":"<p>ModInit is the annotation processor added by LibX. It will create a new class in the same package as your mod class with the name of your mod class and a <code>$</code> added.</p> <p>Different annotations in source code will add content into that class. If you have multiple mods in one project, you need to use <code>@ForMod</code> to tell ModInit which mod to use.</p>"},{"location":"modinit/index.html#loading-models","title":"Loading models","text":"<p>Add <code>@Model</code> to a field of type <code>BakedModel</code> to load a model into that field.</p>"},{"location":"modinit/index.html#registering-configs","title":"Registering Configs","text":"<p>Using <code>@RegisterConfig</code> and <code>@RegisterMapper</code> you can register configs and mappers for the LibX config system.</p>"},{"location":"modinit/index.html#advanced-modinit-features","title":"Advanced ModInit Features","text":"<ul> <li>Codec Generation</li> </ul>"},{"location":"modinit/codecs.html","title":"ModInit Codecs","text":"<p>ModInit can be used to generate simple codecs for classes.</p> <p>To generate a codec for a class, add <code>@PrimaryConstructor</code> to one of its constructors. The constructor parameters will form the codec parameters. By adding different annotations to the constructor parameters, you can customise what kind a parameter is and configure it more precisely. See the javadocs of <code>@PrimaryConstructor</code> for more information.</p> <p>For each parameter, there must either be a public field with the same name, a getter with the same name or a getter in beans style. These are used to get the values when writing in a codec.</p> <p>To get the generated codec, use <code>Codecs.get(Class&lt;?&gt;,Class&lt;?&gt;)</code> with your mods class and the class, the codec was generated for.</p> <p>Parameters can be of any type that fulfills one of the following criteria by default:</p> <ul> <li>DataFixerUpper provides a builtin Codec for that type</li> <li>The class of the parameter has a <code>public</code> <code>static</code> <code>final</code> field named <code>CODEC</code> or <code>DIRECT_CODEC</code> for that type.</li> </ul> <p>Other types can be supported by other annotations.</p>"},{"location":"modinit/registration.html","title":"ModInit Registration","text":"<p>ModInit has a system to register each <code>public static final</code> field from a class into a set registry. If registry tracking is enabled, these fields will also be added as tracking targets for their contained elements. To get started, apply <code>@RegisterClass</code> to your class. The target registry is set by the <code>registry</code> field in <code>@RegisterClass</code>. This can be the empty string to register elements without a registry. (Only really makes sense on <code>Registerable</code>s though) To set a registry, set the field name of a field from either the <code>ForgeRegistries.Keys</code> class or the <code>Registries</code> class. The field must be <code>public static final</code> and have a type of <code>ResourceKey&lt;? extends Registry&lt;T&gt;&gt;</code> where <code>T</code> is the type you want to register in that class.</p> <p>If your registry key is stored in another class, you can use the <code>registryClass</code> field in <code>@RegisterClass</code>. This allows to set another class where the registry key is stored.</p> <p>An example could look like this:</p> <pre><code>@RegisterClass(registry = \"ITEM\")\npublic class ModItems {\n\n    public static final ItemBase rawSteel = new ItemBase(MyMod.getInstance(), new Item.Properties()); // mymod:raw_steel\n    public static final Item steel = new Item(new Item.Properties().tab(MyMod.getInstance().tab)); // mymod:steel\n    public static final Item chickenFricassee = new Item(new Item.Properties().food(Foods.CHICKEN)); // mymod:chicken_fricassee\n}\n</code></pre> <p>The comment after each line shows the id used to register the item.</p>"},{"location":"modinit/registration.html#customizing-elements","title":"Customizing elements","text":"<p>To further customise, how elements are registered, use the annotations from <code>@Reg</code>:</p> <ul> <li><code>@Reg.Exclude</code> will exclude a field from registration.</li> <li><code>@Reg.Name</code> allows to set a custom name used for registration.</li> </ul>"},{"location":"registration/index.html","title":"The LibX Registration System","text":"<p>LibX provides a system to register objects into forge and vanilla registries, that is meant to circumvent some of the flaws, the <code>RegistryObject</code> system has. The LibX system has several advantages over the one provided by forge, such as:</p> <ul> <li>Less code that is more concise.</li> <li>Grouping of objects that belong together but go in different registries.</li> <li>No need for a <code>.get()</code> to access a registered object while there is still the possibility to allow registry replacements on your registered objects.</li> </ul> <p>To get started, implement <code>ModXRegistration</code> with your mod class. You'll now need to override the <code>initRegistration</code> method, where you can tweak some of the more advanced features of the system. For more information, see registry transformers and registry tracking.</p> <p>Next, you need to call <code>ModXRegistration#addRegistrationHandler</code> in your mod constructor with a reference to a method that registers items to your mod. Alternatively, you can use ModInit for that.</p> <p>Inside a registration handler, you can register objects using <code>ModXRegistration#register</code>.</p>"},{"location":"registration/index.html#the-registerable-interface","title":"The Registerable interface","text":"<p>To really make use of the LibX registration system, you can implement the <code>Registerable</code> interface on every object that is registered to the system to further customise, how it's registered. <code>Registerable</code> provides the following methods:</p> <ul> <li><code>registerCommon</code>: Called during <code>FMLCommonSetupEvent</code>.     Gets a context with the id and target registry for the object and a way to enqueue tasks.</li> <li><code>registerClient</code>: Like <code>registerCommon</code> but for <code>FMLClientSetupEvent</code>.</li> <li><code>registerAdditional</code>: This gets an <code>EntryCollector</code> which can be used to register additional objects together with this one.     This can for example be used to register an <code>Item</code> together with a <code>Block</code> or a <code>BlockEntityType</code> together with a <code>MenuType</code>.     For an example, see <code>BlockBase</code>.</li> <li><code>initTracking</code>: Initialises nested registry tracking.</li> </ul> <p>Using these methods, a single object can register a bunch of other things with it. This works for anything, so a single <code>Block</code> could register slabs, stairs, doors, trapdoors, ... by just passing one object to the system.</p>"},{"location":"registration/tracking.html","title":"Registry Tracking","text":"<p>Registry Tracking is the process of keeping your fields updated with the current value from the registry. This also works with <code>final</code> fields. To add a field to the registry tracker, use <code>RegistryTracker#track</code>. This works for both static and instance fields.</p> <p>All fields registered by ModInit will be added to the registry tracker automatically and <code>Registerable#initTracking</code> will be called on all registered elements.</p> <p>If you want to disable registry tracking, call <code>disableRegistryTracking</code> in your <code>initRegistration</code> method.</p>"},{"location":"registration/transformers.html","title":"Registry Conditions and Transformers","text":"<p>Registry conditions and transformers can filter and modify elements before they are passed to the LibX registration system.</p>"},{"location":"registration/transformers.html#registry-conditions","title":"Registry Conditions","text":"<p>Registry Conditions implement the <code>RegistryCondition</code> interface. They have a method called <code>shouldRegister</code> that is called with each object that is about to be registered. Only if all conditions return <code>true</code> for an object, it can be registered. To add a registry condition, use <code>RegistrationBuilder#condition</code> in your <code>initRegistration</code> method.</p> <p>The following condition would exclude all <code>Item</code>s from registration:</p> <pre><code>public class ExcludeItems implements RegistryCondition {\n\n    public boolean shouldRegister(RegistrationContext ctx, Object value) {\n        return ctx.registry().isEmpty() || Registries.ITEM != ctx.registry().get();\n    }\n}\n</code></pre>"},{"location":"registration/transformers.html#registry-transformers","title":"Registry Transformers","text":"<p>Registry Transformers implement the <code>RegistryTransformer</code> interface. They have a method called <code>transform</code> that is called with each object that is about to be registered and passed the registry conditions. That method gets an <code>EntryCollector</code> as argument, which allows to register additional objects together with the original one. To add a registry transformer, use <code>RegistrationBuilder#transformer</code> in your <code>initRegistration</code> method.</p> <p>The following transformer would register a <code>BlockItem</code> with every registered block:</p> <pre><code>public class BlockItems implements RegistryTransformer {\n\n    public void transform(RegistrationContext ctx, Object value, Registerable.EntryCollector builder) {\n        if (value instanceof Block block) {\n            builder.register(Registries.ITEM, new BlockItem(block, new Item.Properties()));\n        }\n    }\n}\n</code></pre>"},{"location":"sandbox/index.html","title":"SandBox","text":"<p>SandBox is the LibX world generation library. SandBox add some new datapack content for world generation and most notably a lot of data providers to generate worldgen data using the LibX datagen system.</p>"},{"location":"sandbox/index.html#the-surface-rule-set-and-biome-surface-registries","title":"The surface rule set and biome surface registries","text":"<p>A <code>SurfaceRuleSet</code> describes, how to dynamically create <code>SurfaceRules</code> based on the biomes that generate in a chunk generator. For each biome, it's possible to register a <code>BiomeSurface</code> with the same name and separate the biome specific surface rules from the generator settings.</p> <p>This makes it considerably easier for other mods to add new biomes to a custom dimension and take the advantage of surface rules.</p>"},{"location":"sandbox/index.html#the-biome-layer-registry","title":"The biome layer registry","text":"<p>A <code>BiomeLayer</code> specifies a set of biomes and matching climate data that can generate in a <code>MultiNoise</code> based biome source. <code>BiomeLayers</code> are designed to make it possible to easily extend a dimension with new biomes without adjusting all the climate target values.</p>"},{"location":"sandbox/index.html#the-template-pool-extension-registry","title":"The template pool extension registry","text":"<p>A <code>PoolExtension</code> specifies new elements that should be added to a template pool without replacing the whole pool in a datapack. This makes it easy to extend structures like villages with custom buildings.</p>"},{"location":"sandbox/index.html#layered-biome-source","title":"Layered biome source","text":"<p>A <code>LayeredBiomeSource</code> behaves like a <code>MultiNoiseBiomeSource</code>, however, it can work with multiple <code>BiomeLayer</code>s and sample each layer in its own noise range, so they don't interfere.</p>"},{"location":"sandbox/index.html#extended-noise-chunk-generator","title":"Extended noise chunk generator","text":"<p>A version of a <code>NoiseBasedChunkGnenerator</code> that is capable of applying a <code>SurfaceRuleSet</code> and matching <code>BiomeSurface</code>.</p>"},{"location":"sandbox/datagen.html","title":"SandBox datagen","text":"<p>SandBox provides a range of data providers for world generation related objects. These make use of the LibX datagen system to extend the datagen registry set.</p> <p>All SandBox providers extend the base class <code>RegistryProviderBase</code>. The subclasses of these providers provide ways to create <code>Holder</code>s of the elements you want to generate. These holders are intrusive and must be properly registered afterwards. <code>RegistryProviderBase</code> makes sure, each <code>public</code>, non-<code>static</code> field in the provider class that has a type of <code>Holder</code> and contains an intrusive holder when the provider runs, is added to the registry.</p> <p>The id of the object is obtained from the field name, however, it's possible to change that id using the <code>@Id</code> annotation.</p>"},{"location":"sandbox/datagen.html#example","title":"Example","text":"<pre><code>public class FeatureProvider extends FeatureProviderBase {\n\n    public final Holder&lt;PlacedFeature&gt; bonusChests = this.placement(this.holder(MiscOverworldFeatures.BONUS_CHEST))\n            .count(2)\n            .rarity(3)\n            .heightmap(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES)\n            .build();\n\n    @Id(namespace = \"minecraft\", value = \"my_cool_feature\")\n    public final Holder&lt;ConfiguredFeature&lt;?, ?&gt;&gt; fillLayer = this.feature(Feature.FILL_LAYER, new LayerConfiguration(\n            3, Blocks.COBWEB.defaultBlockState()\n    ));\n\n    public FeatureProvider(DatagenContext ctx) {\n        super(ctx);\n    }\n}\n</code></pre>"}]}